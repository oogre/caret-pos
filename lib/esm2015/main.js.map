{"version":3,"file":"main.js","sources":["../../src/mirror.js","../../src/utils.js","../../src/input.js","../../src/editable.js","../../src/base.js","../../src/main.js"],"sourcesContent":["const attributes = [\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopStyle',\n  'borderRightStyle',\n  'borderBottomStyle',\n  'borderLeftStyle',\n  'borderTopWidth',\n  'boxSizing',\n  'fontFamily',\n  'fontSize',\n  'fontWeight',\n  'height',\n  'letterSpacing',\n  'lineHeight',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'outlineWidth',\n  'overflow',\n  'overflowX',\n  'overflowY',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'textAlign',\n  'textOverflow',\n  'textTransform',\n  'whiteSpace',\n  'wordBreak',\n  'wordWrap',\n];\n\n/**\n * Create a mirror\n *\n * @param {Element} element The element\n * @param {string} html The html\n *\n * @return {object} The mirror object\n */\nconst createMirror = (element, html) => {\n\n  /**\n   * The mirror element\n   */\n  const mirror = document.createElement('div');\n\n  /**\n   * Create the CSS for the mirror object\n   *\n   * @return {object} The style object\n   */\n  const mirrorCss = () => {\n    const css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -2000\n    };\n\n    if (element.tagName === 'TEXTAREA') {\n      attributes.push('width');\n    }\n\n    attributes.forEach((attr) => {\n      css[attr] = getComputedStyle(element)[attr];\n    });\n\n    return css;\n  };\n\n  /**\n   * Initialize the mirror\n   *\n   * @param {string} html The html\n   *\n   * @return {void}\n   */\n  const initialize = (html) => {\n    const styles = mirrorCss();\n    Object.keys(styles).forEach(key => {\n      mirror.style[key] = styles[key];\n    });\n    mirror.innerHTML = html;\n    element.parentNode.insertBefore(mirror, element.nextSibling);\n  };\n\n  /**\n   * Get the rect\n   *\n   * @return {Rect} The bounding rect\n   */\n  const rect = () => {\n    const marker = mirror.ownerDocument.getElementById('caret-position-marker');\n    const boundingRect = {\n      left: marker.offsetLeft,\n      top: marker.offsetTop,\n      height: marker.offsetHeight\n    };\n    mirror.parentNode.removeChild(mirror);\n\n    return boundingRect;\n  };\n\n  initialize(html);\n\n  return {\n    rect,\n  };\n};\n\nexport default createMirror;\n","/**\n * Check if a DOM Element is content editable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is content editable\n */\nexport const isContentEditable = (element) => !!(\n  element.contentEditable &&\n  element.contentEditable === 'true'\n);\n\n/**\n * Get the context from settings passed in\n *\n * @param {object} settings The settings object\n *\n * @return {object} window and document\n */\nexport const getContext = (settings = {}) => {\n  const { customPos, iframe, noShadowCaret } = settings;\n  if (iframe) {\n    return {\n      iframe,\n      window: iframe.contentWindow,\n      document: iframe.contentDocument || iframe.contentWindow.document,\n      noShadowCaret,\n      customPos,\n    };\n  }\n\n  return {\n    window,\n    document,\n    noShadowCaret,\n    customPos,\n  };\n};\n\n/**\n * Get the offset of an element\n *\n * @param {Element} element The DOM element\n * @param {object} ctx The context\n *\n * @return {object} top and left\n */\nexport const getOffset = (element, ctx) => {\n  const win = ctx && ctx.window || window;\n  const doc = ctx && ctx.document || document;\n  const rect = element.getBoundingClientRect();\n  const docEl = doc.documentElement;\n  const scrollLeft = win.pageXOffset || docEl.scrollLeft;\n  const scrollTop = win.pageYOffset || docEl.scrollTop;\n\n  return {\n    top: rect.top + scrollTop,\n    left: rect.left + scrollLeft\n  };\n};\n\n/**\n * Check if a value is an object\n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is an object\n */\nexport const isObject = (value) => typeof value === 'object' && value !== null;\n\n\n/**\n * Return contentEditable Parent\n *\n * @param {Element} element The DOM element\n *\n * @return {bool} If element is not a child of contentEditable\n * @return {Element} contentEditable\n */\nexport const getContentEditableInParent = (element) => {\n  if(isContentEditable(element)){\n    return element;\n  }\n  if(element.parentElement){\n    return getContentEditableInParent(element.parentElement);  \n  }\n  return false;\n};\n\n/**\n * Check if a DOM Element is an input field\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is input or textarea\n */\nexport const isInputField = (element) => {\n  let nodeName = element.nodeName;\n  return nodeName == 'TEXTAREA' || nodeName == 'INPUT';\n};\n\n/**\n * Check if a DOM Element is an input field or child of contentEditable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} false it is not an input field nor a contentEditable child\n * @return {Element} input field or the contentEditable parent\n */\nexport const checkTarget = (element) => {\n  if(!isInputField(element)){\n    element = getContentEditableInParent(element);\n  }\n  return element;\n};\n\n/**\n * Get the text content of a DOM Element or a NodeList \n *\n * @param {Element} element The DOM element\n * @param {NodeList} elements The DOM element\n *\n * @return {string} the content text\n */\nexport const getContent = (element) => {\n  if(element instanceof NodeList) [].slice.call(element).reduce((memo, e) => memo += getContent(e), '');\n  if(! (element instanceof Element)) return '';\n  if(isInputField(element)) return element.value;\n  return element.innerHTML.replace(/(<([^>]+)>)/ig, ''); \n};\n\n/**\n * Check if a value is a functio \n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is a function\n */\nexport const isFunction = (fnc) => fnc && {}.toString.call(fnc) === '[object Function]';\n","import createMirror from './mirror';\nimport { getOffset as elementOffset } from './utils';\n\n/**\n * Create a Input caret object.\n *\n * @param {Element} element The element\n * @param {Object} ctx The context\n */\nconst createInputCaret = (element, ctx) => {\n\n  /**\n   * Get the current position\n   *\n   * @returns {int} The caret position\n   */\n  const getPos = () => {\n    return element.selectionStart;\n  };\n\n  const get = () => {\n    return {\n      element : element,\n      Start : element.selectionStart, \n      End : element.selectionEnd\n    };\n  };\n\n  /**\n   * Set the position\n   *\n   * @param {int} pos The position\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    element.setSelectionRange(pos, pos);\n\n    return element;\n  };\n\n  /**\n   * The offset\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The offset\n   */\n  const getOffset = (pos) => {\n    const rect = elementOffset(element);\n    const position = getPosition(pos);\n\n    return {\n      top: rect.top + position.top + ctx.document.body.scrollTop,\n      left: rect.left + position.left + ctx.document.body.scrollLeft,\n      height: position.height,\n    };\n  };\n\n  /**\n   * Get the current position\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The position\n   */\n  const getPosition = (pos) => {\n    const format = (val) => {\n      let value = val.replace(/<|>|`|\"|&/g, '?')\n        .replace(/\\r\\n|\\r|\\n/g,'<br/>');\n      return value;\n    };\n\n    if (ctx.customPos || ctx.customPos === 0) {\n      pos = ctx.customPos;\n    }\n\n    const position = pos === undefined ? getPos() : pos;\n    const startRange = element.value.slice(0, position);\n    const endRange = element.value.slice(position);\n    let html = `<span style=\"position: relative; display: inline;\">${format(startRange)}</span>`;\n    html += '<span id=\"caret-position-marker\" style=\"position: relative; display: inline;\">|</span>';\n    html += `<span style=\"position: relative; display: inline;\">${format(endRange)}</span>`;\n\n    const mirror = createMirror(element, html);\n    const rect = mirror.rect();\n    rect.pos = getPos();\n\n    return rect;\n  };\n\n  return {\n    get,\n    getPos,\n    setPos,\n    getOffset,\n    getPosition,\n  };\n};\n\nexport default createInputCaret;\n","\nimport {\n  getContentEditableInParent,\n  //isContentEditable,\n  getContent\n} from './utils';\n\n/**\n * Create an Editable Caret\n * @param {Element} element The editable element\n * @param {object|null} ctx The context\n *\n * @return {EditableCaret}\n */\nconst createEditableCaret = (element, ctx) => {\n\n  /**\n   * Set the caret position\n   *\n   * @param {int} pos The position to se\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    const sel = ctx.window.getSelection();\n    if (sel) {\n      let offset = 0;\n      let found = false;\n      const find = (position, parent) => {\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          const node = parent.childNodes[i];\n          if (found) {\n            break;\n          }\n          if (node.nodeType === 3) {\n            if (offset + node.length >= position) {\n              found = true;\n              const range = ctx.document.createRange();\n              range.setStart(node, position - offset);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              break;\n            } else {\n              offset += node.length;\n            }\n          } else {\n            find(pos, node);\n          }\n        }\n      };\n      find(pos, element);\n    }\n\n    return element;\n  };\n\n  /**\n   * Get the offset\n   *\n   * @return {object} The offset\n   */\n  const getOffset = () => {\n    const range = getRange();\n    let offset = {\n      height: 0,\n      left: 0,\n      right: 0,\n    };\n\n    if (!range) {\n      return offset;\n    }\n\n    const hasCustomPos = ctx.customPos || ctx.customPos === 0;\n\n    // endContainer in Firefox would be the element at the start of\n    // the line\n    if ((range.endOffset - 1 > 0 && range.endContainer !== element) || hasCustomPos) {\n      const clonedRange = range.cloneRange();\n      const fixedPosition = hasCustomPos ? ctx.customPos : range.endOffset;\n      clonedRange.setStart(range.endContainer, fixedPosition - 1 < 0 ? 0 : fixedPosition - 1);\n      clonedRange.setEnd(range.endContainer, fixedPosition);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left + rect.width,\n        top: rect.top,\n      };\n      clonedRange.detach();\n    }\n\n    if ((!offset || (offset && offset.height === 0)) && !ctx.noShadowCaret) {\n      const clonedRange = range.cloneRange();\n      const shadowCaret = ctx.document.createTextNode('|');\n      clonedRange.insertNode(shadowCaret);\n      clonedRange.selectNode(shadowCaret);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left,\n        top: rect.top,\n      };\n      shadowCaret.parentNode.removeChild(shadowCaret);\n      clonedRange.detach();\n    }\n\n    if (offset) {\n      const doc = ctx.document.documentElement;\n      offset.top += ctx.window.pageYOffset - (doc.clientTop || 0);\n      offset.left += ctx.window.pageXOffset - (doc.clientLeft || 0);\n    }\n\n    return offset;\n  };\n\n  /**\n   * Get the position\n   *\n   * @return {object} The position\n   */\n  const getPosition = () => {\n    const offset = getOffset();\n    const pos = getPos();\n    const rect = element.getBoundingClientRect();\n    const inputOffset = {\n      top: rect.top + ctx.document.body.scrollTop,\n      left: rect.left + ctx.document.body.scrollLeft\n    };\n    offset.left -= inputOffset.left;\n    offset.top -= inputOffset.top;\n    offset.pos = pos;\n\n    return offset;\n  };\n\n  /**\n   * Get the caret range\n   *\n   * @return {Range|null}\n   */\n  const get = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n    if(sel.rangeCount > 0){\n      let range = sel.getRangeAt(0);\n      \n      let e = range.startContainer;\n      let ce = getContentEditableInParent(e);\n      let all = getContent(ce);\n      console.log(e, all, range);\n\n      return {\n        element : range.startContainer,\n        Start : range.startOffset, \n        End : range.endOffset\n      };\n    }\n  };\n  /**\n   * Get the range\n   *\n   * @return {Range|null}\n   */\n  const getRange = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n    return sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n  };\n\n  /**\n   * Get the caret position\n   *\n   * @return {int} The position\n   */\n  const getPos = () => {\n    const range = getRange();\n    const clonedRange = range.cloneRange();\n    clonedRange.selectNodeContents(element);\n    clonedRange.setEnd(range.endContainer, range.endOffset);\n    const pos = clonedRange.toString().length;\n    clonedRange.detach();\n\n    return pos;\n  };\n\n  return {\n    get,\n    getPos,\n    setPos,\n    getPosition,\n    getOffset,\n    getRange,\n  };\n};\n\nexport default createEditableCaret;\n","/*----------------------------------------*\\\n  bcksp.es - base.js\n  @author Evrard Vincent (vincent@ogre.be)\n  @Date:   2018-12-18 16:54:39\n  @Last Modified time: 2018-12-18 16:54:50\n\\*----------------------------------------*/\nimport createInputCaret from './input';\nimport createEditableCaret from './editable';\nimport {\n  isContentEditable,\n  getContext,\n  isObject,\n} from './utils';\n\nexport { getOffset } from './utils';\n\nconst createCaret = (element, ctx) => {\n  if (isContentEditable(element)) {\n    return createEditableCaret(element, ctx);\n  }\n\n  return createInputCaret(element, ctx);\n};\n\nexport const position = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n  if (value || value === 0) {\n    return caret.setPos(value);\n  }\n\n  return caret.getPosition();\n};\nexport const caretPosition = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n\n  return caret;\n};\n\n/**\n *\n * @param {Element} element The DOM element\n * @param {number|undefined} value The value to set\n * @param {object} settings Any settings for context\n */\nexport const offset = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n  return caret.getOffset(value);\n};\n","import * as CaretPos from './base.js';\nimport {\n  getContent,\n  checkTarget,\n  isFunction\n} from './utils';\n\nclass CaretUtil{\n  constructor(){\n    this.CaretPos = CaretPos;\n    this.caret;\n    this.target;\n    this.startAt;\n    this.stopAt;\n  }\n  _triggerCaretChange(event){\n    this.caretChangeHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  _triggerCaretOff(event){\n    this.caretOffHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  _triggerCaretOn(event){\n    this.caretOnHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  onCaretChange(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretChange must receive a function as parameter');\n    this.caretChangeHandler.push(fnc);\n  }\n  onCaretOff(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretOff must receive a function as parameter');\n    this.caretOffHandler.push(fnc);\n  }\n  onCaretOn(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretOn must receive a function as parameter');\n    this.caretOnHandler.push(fnc);\n  }\n  disable(){\n    if(this.target != null){\n      this.target.removeEventListener('blur', this._autoDisableHandler, true);\n      this._triggerCaretOff({\n        type : 'CaretOff',\n        target : this.target,\n      });\n    }\n    this.target = null;\n    this.startAt = null;\n    this.stopAt = null;\n  }\n  _autoDisableHandler(){}\n  enable(target){\n    if(!(target instanceof Element))throw new Error('Caret must receive an Element as target');\n    this.caret = this.CaretPos.caretPosition(target);\n    let range = this.caret.get();\n    if(isNaN(range.Start) || isNaN(range.End) || range.Start < 0 || range.End < 0)throw new Error('Troubble during Ranging');\n    if(this.target != target){\n      this._triggerCaretOn({\n        type : 'CaretOn',\n        target : target\n      });\n      let self = this;\n      this._autoDisableHandler = function(){\n        self.disable();\n      };\n      target.addEventListener('blur', this._autoDisableHandler, true);\n    }\n\n    this.target = target;\n    this.startAt = range.Start;\n    this.stopAt = range.End;\n  }\n  getTarget(){\n    return this.target;\n  }\n  getSelectedText(){\n    if(!this.target || this.startAt == this.stopAt)return null;\n    let content = getContent(this.target);\n    return content.substring(this.startAt, this.stopAt);\n  }\n  getCharBeforCaret(){\n    if(!this.target || this.startAt<1)return null;\n    let content = getContent(this.target);\n    return content.charAt(this.startAt-1);\n  }\n}\n\nexport class Caret extends CaretUtil{\n  constructor(target = document, initListener = true){\n    super();\n    this.caretChangeHandler = [];\n    this.caretOffHandler = [];\n    this.caretOnHandler = [];\n\n    if(initListener){\n      if ( document.readyState !== 'complete' ){\n        window.onload = ()=>this._init(target);  \n      }else{\n        this._init(target);\n      }\n    }\n  }\n  _init(target){\n    if(typeof target === 'string'){\n      target = document.querySelectorAll(target);\n    }\n    let start = (target)=>{\n      target.addEventListener('keyup', this._handleEvent.bind(this), true);\n      target.addEventListener('mouseup', this._handleEvent.bind(this), true);\n    };\n   \n    if(target instanceof NodeList){\n      target.forEach(start);\n    }else if(target instanceof Element){\n      start(target);\n    }else if(target instanceof Document){\n      start(target);\n    }\n  }\n\n  _beforeHandleBlurEvent(){}\n  _handleEvent(event){\n    event.preventDefault();\n    let target;\n    if(false !== (target = checkTarget(event.target))){\n      this.enable(target);\n      \n      \n      this._triggerCaretChange({\n        type : 'CaretChange',\n        target : this.target,\n        caret : this.caret,\n        startAt : this.startAt, \n        stopAt : this.stopAt,\n        content : getContent(this.target),\n        selectedText : this.getSelectedText(),\n        charBeforCaret : this.getCharBeforCaret()\n      });\n    }else{\n      this.disable();\n    }\n    return true;\n  }\n}"],"names":["attributes","createMirror","element","html","mirror","document","createElement","mirrorCss","css","tagName","push","forEach","attr","getComputedStyle","initialize","styles","keys","style","key","innerHTML","parentNode","insertBefore","nextSibling","rect","marker","ownerDocument","getElementById","boundingRect","offsetLeft","offsetTop","offsetHeight","removeChild","isContentEditable","contentEditable","getContext","settings","customPos","iframe","noShadowCaret","contentWindow","contentDocument","getOffset","ctx","win","window","doc","getBoundingClientRect","docEl","documentElement","scrollLeft","pageXOffset","scrollTop","pageYOffset","top","left","isObject","value","getContentEditableInParent","parentElement","isInputField","nodeName","checkTarget","getContent","NodeList","slice","call","reduce","memo","e","Element","replace","isFunction","fnc","toString","createInputCaret","getPos","selectionStart","get","selectionEnd","setPos","pos","setSelectionRange","elementOffset","position","getPosition","body","height","format","val","undefined","startRange","endRange","createEditableCaret","sel","getSelection","offset","found","find","parent","i","childNodes","length","node","nodeType","range","createRange","setStart","removeAllRanges","addRange","getRange","hasCustomPos","endOffset","endContainer","clonedRange","cloneRange","fixedPosition","setEnd","width","detach","shadowCaret","createTextNode","insertNode","selectNode","clientTop","clientLeft","inputOffset","rangeCount","getRangeAt","startContainer","ce","all","log","startOffset","selectNodeContents","createCaret","options","caret","caretPosition","CaretUtil","CaretPos","target","startAt","stopAt","event","caretChangeHandler","map","caretOffHandler","caretOnHandler","Error","removeEventListener","_autoDisableHandler","_triggerCaretOff","isNaN","Start","End","_triggerCaretOn","self","disable","addEventListener","content","substring","charAt","Caret","initListener","readyState","onload","_init","querySelectorAll","start","_handleEvent","bind","Document","preventDefault","enable","_triggerCaretChange","getSelectedText","getCharBeforCaret"],"mappings":"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"}