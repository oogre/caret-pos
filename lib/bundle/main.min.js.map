{"version":3,"sources":["../../src/mirror.js","../../src/utils.js","../../src/base.js","../../src/editable.js","../../src/input.js","../../src/main.js"],"names":["attributes","createMirror","element","html","css","styles","mirror","document","createElement","tagName","push","forEach","attr","getComputedStyle","keys","key","style","innerHTML","parentNode","insertBefore","nextSibling","marker","ownerDocument","getElementById","boundingRect","offsetLeft","offsetTop","offsetHeight","removeChild","isContentEditable","contentEditable","getContext","settings","arguments","length","undefined","customPos","iframe","noShadowCaret","contentWindow","contentDocument","getOffset","ctx","win","window","doc","rect","getBoundingClientRect","docEl","documentElement","scrollLeft","pageXOffset","scrollTop","pageYOffset","top","left","isObject","value","_typeof","isInputField","nodeName","checkTarget","getContentEditableInParent","parentElement","getContent","NodeList","slice","call","reduce","memo","e","Element","replace","isFunction","fnc","toString","createCaret","getSelection","sel","rangeCount","range","getRangeAt","startContainer","startOffset","endOffset","getPos","getRange","clonedRange","cloneRange","selectNodeContents","setEnd","endContainer","pos","detach","offset","found","find","position","parent","i","childNodes","node","nodeType","createRange","setStart","removeAllRanges","addRange","inputOffset","body","hasCustomPos","fixedPosition","height","width","shadowCaret","createTextNode","insertNode","selectNode","clientTop","clientLeft","getPosition","format","val","startRange","endRange","selectionStart","selectionEnd","setSelectionRange","elementOffset","options","caret","setPos","CaretUtil","CaretPos","target","startAt","stopAt","event","caretChangeHandler","map","handler","caretOffHandler","caretOnHandler","Error","this","removeEventListener","_autoDisableHandler","_triggerCaretOff","caretPosition","get","isNaN","Start","End","_triggerCaretOn","self","disable","addEventListener","substring","charAt","Caret","_CaretUtil","initListener","readyState","onload","_this","_init","querySelectorAll","start","_this2","_handleEvent","bind","Document","preventDefault","enable","_triggerCaretChange","getSelectedText","getCharBeforCaret"],"mappings":"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","file":"main.min.js","sourcesContent":["const attributes = [\n  'borderBottomWidth',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopStyle',\n  'borderRightStyle',\n  'borderBottomStyle',\n  'borderLeftStyle',\n  'borderTopWidth',\n  'boxSizing',\n  'fontFamily',\n  'fontSize',\n  'fontWeight',\n  'height',\n  'letterSpacing',\n  'lineHeight',\n  'marginBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'outlineWidth',\n  'overflow',\n  'overflowX',\n  'overflowY',\n  'paddingBottom',\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'textAlign',\n  'textOverflow',\n  'textTransform',\n  'whiteSpace',\n  'wordBreak',\n  'wordWrap',\n];\n\n/**\n * Create a mirror\n *\n * @param {Element} element The element\n * @param {string} html The html\n *\n * @return {object} The mirror object\n */\nconst createMirror = (element, html) => {\n\n  /**\n   * The mirror element\n   */\n  const mirror = document.createElement('div');\n\n  /**\n   * Create the CSS for the mirror object\n   *\n   * @return {object} The style object\n   */\n  const mirrorCss = () => {\n    const css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -2000\n    };\n\n    if (element.tagName === 'TEXTAREA') {\n      attributes.push('width');\n    }\n\n    attributes.forEach((attr) => {\n      css[attr] = getComputedStyle(element)[attr];\n    });\n\n    return css;\n  };\n\n  /**\n   * Initialize the mirror\n   *\n   * @param {string} html The html\n   *\n   * @return {void}\n   */\n  const initialize = (html) => {\n    const styles = mirrorCss();\n    Object.keys(styles).forEach(key => {\n      mirror.style[key] = styles[key];\n    });\n    mirror.innerHTML = html;\n    element.parentNode.insertBefore(mirror, element.nextSibling);\n  };\n\n  /**\n   * Get the rect\n   *\n   * @return {Rect} The bounding rect\n   */\n  const rect = () => {\n    const marker = mirror.ownerDocument.getElementById('caret-position-marker');\n    const boundingRect = {\n      left: marker.offsetLeft,\n      top: marker.offsetTop,\n      height: marker.offsetHeight\n    };\n    mirror.parentNode.removeChild(mirror);\n\n    return boundingRect;\n  };\n\n  initialize(html);\n\n  return {\n    rect,\n  };\n};\n\nexport default createMirror;\n","/**\n * Check if a DOM Element is content editable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is content editable\n */\nexport const isContentEditable = (element) => !!(\n  element.contentEditable &&\n  element.contentEditable === 'true'\n);\n\n/**\n * Get the context from settings passed in\n *\n * @param {object} settings The settings object\n *\n * @return {object} window and document\n */\nexport const getContext = (settings = {}) => {\n  const { customPos, iframe, noShadowCaret } = settings;\n  if (iframe) {\n    return {\n      iframe,\n      window: iframe.contentWindow,\n      document: iframe.contentDocument || iframe.contentWindow.document,\n      noShadowCaret,\n      customPos,\n    };\n  }\n\n  return {\n    window,\n    document,\n    noShadowCaret,\n    customPos,\n  };\n};\n\n/**\n * Get the offset of an element\n *\n * @param {Element} element The DOM element\n * @param {object} ctx The context\n *\n * @return {object} top and left\n */\nexport const getOffset = (element, ctx) => {\n  const win = ctx && ctx.window || window;\n  const doc = ctx && ctx.document || document;\n  const rect = element.getBoundingClientRect();\n  const docEl = doc.documentElement;\n  const scrollLeft = win.pageXOffset || docEl.scrollLeft;\n  const scrollTop = win.pageYOffset || docEl.scrollTop;\n\n  return {\n    top: rect.top + scrollTop,\n    left: rect.left + scrollLeft\n  };\n};\n\n/**\n * Check if a value is an object\n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is an object\n */\nexport const isObject = (value) => typeof value === 'object' && value !== null;\n\n\n/**\n * Return contentEditable Parent\n *\n * @param {Element} element The DOM element\n *\n * @return {bool} If element is not a child of contentEditable\n * @return {Element} contentEditable\n */\nexport const getContentEditableInParent = (element) => {\n  if(isContentEditable(element)){\n    return element;\n  }\n  if(element.parentElement){\n    return getContentEditableInParent(element.parentElement);  \n  }\n  return false;\n};\n\n/**\n * Check if a DOM Element is an input field\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} If it is input or textarea\n */\nexport const isInputField = (element) => {\n  let nodeName = element.nodeName;\n  return nodeName == 'TEXTAREA' || nodeName == 'INPUT';\n};\n\n/**\n * Check if a DOM Element is an input field or child of contentEditable\n *\n * @param {Element} element  The DOM element\n *\n * @return {bool} false it is not an input field nor a contentEditable child\n * @return {Element} input field or the contentEditable parent\n */\nexport const checkTarget = (element) => {\n  if(!isInputField(element)){\n    element = getContentEditableInParent(element);\n  }\n  return element;\n};\n\n/**\n * Get the text content of a DOM Element or a NodeList \n *\n * @param {Element} element The DOM element\n * @param {NodeList} elements The DOM element\n *\n * @return {string} the content text\n */\nexport const getContent = (element) => {\n  if(element instanceof NodeList) [].slice.call(element).reduce((memo, e) => memo += getContent(e), '');\n  if(! (element instanceof Element)) return '';\n  if(isInputField(element)) return element.value;\n  return element.innerHTML.replace(/(<([^>]+)>)/ig, ''); \n};\n\n/**\n * Check if a value is a functio \n *\n * @param {any} value The value to check\n *\n * @return {bool} If it is a function\n */\nexport const isFunction = (fnc) => fnc && {}.toString.call(fnc) === '[object Function]';\n","/*----------------------------------------*\\\n  bcksp.es - base.js\n  @author Evrard Vincent (vincent@ogre.be)\n  @Date:   2018-12-18 16:54:39\n  @Last Modified time: 2018-12-18 16:54:50\n\\*----------------------------------------*/\nimport createInputCaret from './input';\nimport createEditableCaret from './editable';\nimport {\n  isContentEditable,\n  getContext,\n  isObject,\n} from './utils';\n\nexport { getOffset } from './utils';\n\nconst createCaret = (element, ctx) => {\n  if (isContentEditable(element)) {\n    return createEditableCaret(element, ctx);\n  }\n\n  return createInputCaret(element, ctx);\n};\n\nexport const position = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n  if (value || value === 0) {\n    return caret.setPos(value);\n  }\n\n  return caret.getPosition();\n};\nexport const caretPosition = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n\n\n  return caret;\n};\n\n/**\n *\n * @param {Element} element The DOM element\n * @param {number|undefined} value The value to set\n * @param {object} settings Any settings for context\n */\nexport const offset = (element, value, settings = {}) => {\n  let options = settings;\n  if (isObject(value)) {\n    options = value;\n    value = null;\n  }\n\n  const ctx = getContext(options);\n  const caret = createCaret(element, ctx);\n  return caret.getOffset(value);\n};\n","/*\nimport {\n  //getContentEditableInParent,\n  //isContentEditable,\n  //getContent\n} from './utils';\n*/\n/**\n * Create an Editable Caret\n * @param {Element} element The editable element\n * @param {object|null} ctx The context\n *\n * @return {EditableCaret}\n */\nconst createEditableCaret = (element, ctx) => {\n\n  /**\n   * Set the caret position\n   *\n   * @param {int} pos The position to se\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    const sel = ctx.window.getSelection();\n    if (sel) {\n      let offset = 0;\n      let found = false;\n      const find = (position, parent) => {\n        for (let i = 0; i < parent.childNodes.length; i++) {\n          const node = parent.childNodes[i];\n          if (found) {\n            break;\n          }\n          if (node.nodeType === 3) {\n            if (offset + node.length >= position) {\n              found = true;\n              const range = ctx.document.createRange();\n              range.setStart(node, position - offset);\n              sel.removeAllRanges();\n              sel.addRange(range);\n              break;\n            } else {\n              offset += node.length;\n            }\n          } else {\n            find(pos, node);\n          }\n        }\n      };\n      find(pos, element);\n    }\n\n    return element;\n  };\n\n  /**\n   * Get the offset\n   *\n   * @return {object} The offset\n   */\n  const getOffset = () => {\n    const range = getRange();\n    let offset = {\n      height: 0,\n      left: 0,\n      right: 0,\n    };\n\n    if (!range) {\n      return offset;\n    }\n\n    const hasCustomPos = ctx.customPos || ctx.customPos === 0;\n\n    // endContainer in Firefox would be the element at the start of\n    // the line\n    if ((range.endOffset - 1 > 0 && range.endContainer !== element) || hasCustomPos) {\n      const clonedRange = range.cloneRange();\n      const fixedPosition = hasCustomPos ? ctx.customPos : range.endOffset;\n      clonedRange.setStart(range.endContainer, fixedPosition - 1 < 0 ? 0 : fixedPosition - 1);\n      clonedRange.setEnd(range.endContainer, fixedPosition);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left + rect.width,\n        top: rect.top,\n      };\n      clonedRange.detach();\n    }\n\n    if ((!offset || (offset && offset.height === 0)) && !ctx.noShadowCaret) {\n      const clonedRange = range.cloneRange();\n      const shadowCaret = ctx.document.createTextNode('|');\n      clonedRange.insertNode(shadowCaret);\n      clonedRange.selectNode(shadowCaret);\n      const rect = clonedRange.getBoundingClientRect();\n      offset = {\n        height: rect.height,\n        left: rect.left,\n        top: rect.top,\n      };\n      shadowCaret.parentNode.removeChild(shadowCaret);\n      clonedRange.detach();\n    }\n\n    if (offset) {\n      const doc = ctx.document.documentElement;\n      offset.top += ctx.window.pageYOffset - (doc.clientTop || 0);\n      offset.left += ctx.window.pageXOffset - (doc.clientLeft || 0);\n    }\n\n    return offset;\n  };\n\n  /**\n   * Get the position\n   *\n   * @return {object} The position\n   */\n  const getPosition = () => {\n    const offset = getOffset();\n    const pos = getPos();\n    const rect = element.getBoundingClientRect();\n    const inputOffset = {\n      top: rect.top + ctx.document.body.scrollTop,\n      left: rect.left + ctx.document.body.scrollLeft\n    };\n    offset.left -= inputOffset.left;\n    offset.top -= inputOffset.top;\n    offset.pos = pos;\n\n    return offset;\n  };\n\n  /**\n   * Get the caret range\n   *\n   * @return {Range|null}\n   */\n  const get = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n    if(sel.rangeCount > 0){\n      let range = sel.getRangeAt(0);\n      \n      //let e = range.startContainer;\n      //let ce = getContentEditableInParent(e);\n      //let all = getContent(ce);\n      return {\n        element : range.startContainer,\n        Start : range.startOffset, \n        End : range.endOffset\n      };\n    }\n  };\n  /**\n   * Get the range\n   *\n   * @return {Range|null}\n   */\n  const getRange = () => {\n    if (!ctx.window.getSelection) {\n      return;\n    }\n    const sel = ctx.window.getSelection();\n    return sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n  };\n\n  /**\n   * Get the caret position\n   *\n   * @return {int} The position\n   */\n  const getPos = () => {\n    const range = getRange();\n    const clonedRange = range.cloneRange();\n    clonedRange.selectNodeContents(element);\n    clonedRange.setEnd(range.endContainer, range.endOffset);\n    const pos = clonedRange.toString().length;\n    clonedRange.detach();\n\n    return pos;\n  };\n\n  return {\n    get,\n    getPos,\n    setPos,\n    getPosition,\n    getOffset,\n    getRange,\n  };\n};\n\nexport default createEditableCaret;\n","import createMirror from './mirror';\nimport { getOffset as elementOffset } from './utils';\n\n/**\n * Create a Input caret object.\n *\n * @param {Element} element The element\n * @param {Object} ctx The context\n */\nconst createInputCaret = (element, ctx) => {\n\n  /**\n   * Get the current position\n   *\n   * @returns {int} The caret position\n   */\n  const getPos = () => {\n    return element.selectionStart;\n  };\n\n  const get = () => {\n    return {\n      element : element,\n      Start : element.selectionStart, \n      End : element.selectionEnd\n    };\n  };\n\n  /**\n   * Set the position\n   *\n   * @param {int} pos The position\n   *\n   * @return {Element} The element\n   */\n  const setPos = (pos) => {\n    element.setSelectionRange(pos, pos);\n\n    return element;\n  };\n\n  /**\n   * The offset\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The offset\n   */\n  const getOffset = (pos) => {\n    const rect = elementOffset(element);\n    const position = getPosition(pos);\n\n    return {\n      top: rect.top + position.top + ctx.document.body.scrollTop,\n      left: rect.left + position.left + ctx.document.body.scrollLeft,\n      height: position.height,\n    };\n  };\n\n  /**\n   * Get the current position\n   *\n   * @param {int} pos The position\n   *\n   * @return {object} The position\n   */\n  const getPosition = (pos) => {\n    const format = (val) => {\n      let value = val.replace(/<|>|`|\"|&/g, '?')\n        .replace(/\\r\\n|\\r|\\n/g,'<br/>');\n      return value;\n    };\n\n    if (ctx.customPos || ctx.customPos === 0) {\n      pos = ctx.customPos;\n    }\n\n    const position = pos === undefined ? getPos() : pos;\n    const startRange = element.value.slice(0, position);\n    const endRange = element.value.slice(position);\n    let html = `<span style=\"position: relative; display: inline;\">${format(startRange)}</span>`;\n    html += '<span id=\"caret-position-marker\" style=\"position: relative; display: inline;\">|</span>';\n    html += `<span style=\"position: relative; display: inline;\">${format(endRange)}</span>`;\n\n    const mirror = createMirror(element, html);\n    const rect = mirror.rect();\n    rect.pos = getPos();\n\n    return rect;\n  };\n\n  return {\n    get,\n    getPos,\n    setPos,\n    getOffset,\n    getPosition,\n  };\n};\n\nexport default createInputCaret;\n","import * as CaretPos from './base.js';\nimport {\n  getContent,\n  checkTarget,\n  isFunction\n} from './utils';\n\nclass CaretUtil{\n  constructor(){\n    this.CaretPos = CaretPos;\n    this.caret;\n    this.target;\n    this.startAt;\n    this.stopAt;\n  }\n  _triggerCaretChange(event){\n    this.caretChangeHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  _triggerCaretOff(event){\n    this.caretOffHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  _triggerCaretOn(event){\n    this.caretOnHandler.map(handler=>{\n      handler(event);\n    });\n  }\n  onCaretChange(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretChange must receive a function as parameter');\n    this.caretChangeHandler.push(fnc);\n  }\n  onCaretOff(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretOff must receive a function as parameter');\n    this.caretOffHandler.push(fnc);\n  }\n  onCaretOn(fnc){\n    if(!isFunction(fnc))throw new Error('onCaretOn must receive a function as parameter');\n    this.caretOnHandler.push(fnc);\n  }\n  disable(){\n    if(this.target != null){\n      this.target.removeEventListener('blur', this._autoDisableHandler, true);\n      this._triggerCaretOff({\n        type : 'CaretOff',\n        target : this.target,\n      });\n    }\n    this.target = null;\n    this.startAt = null;\n    this.stopAt = null;\n  }\n  _autoDisableHandler(){}\n  enable(target){\n    if(!(target instanceof Element))throw new Error('Caret must receive an Element as target');\n    this.caret = this.CaretPos.caretPosition(target);\n    let range = this.caret.get();\n    if(isNaN(range.Start) || isNaN(range.End) || range.Start < 0 || range.End < 0)throw new Error('Troubble during Ranging');\n    if(this.target != target){\n      this._triggerCaretOn({\n        type : 'CaretOn',\n        target : target\n      });\n      let self = this;\n      this._autoDisableHandler = function(){\n        self.disable();\n      };\n      target.addEventListener('blur', this._autoDisableHandler, true);\n    }\n\n    this.target = target;\n    this.startAt = range.Start;\n    this.stopAt = range.End;\n  }\n  getTarget(){\n    return this.target;\n  }\n  getSelectedText(){\n    if(!this.target || this.startAt == this.stopAt)return null;\n    let content = getContent(this.target);\n    return content.substring(this.startAt, this.stopAt);\n  }\n  getCharBeforCaret(){\n    if(!this.target || this.startAt<1)return null;\n    let content = getContent(this.target);\n    return content.charAt(this.startAt-1);\n  }\n}\n\nexport class Caret extends CaretUtil{\n  constructor(target = document, initListener = true){\n    super();\n    this.caretChangeHandler = [];\n    this.caretOffHandler = [];\n    this.caretOnHandler = [];\n\n    if(initListener){\n      if ( document.readyState !== 'complete' ){\n        window.onload = ()=>this._init(target);  \n      }else{\n        this._init(target);\n      }\n    }\n  }\n  _init(target){\n    if(typeof target === 'string'){\n      target = document.querySelectorAll(target);\n    }\n    let start = (target)=>{\n      target.addEventListener('keyup', this._handleEvent.bind(this), true);\n      target.addEventListener('mouseup', this._handleEvent.bind(this), true);\n    };\n   \n    if(target instanceof NodeList){\n      target.forEach(start);\n    }else if(target instanceof Element){\n      start(target);\n    }else if(target instanceof Document){\n      start(target);\n    }\n  }\n\n  _beforeHandleBlurEvent(){}\n  _handleEvent(event){\n    event.preventDefault();\n    let target;\n    if(false !== (target = checkTarget(event.target))){\n      this.enable(target);\n      \n      \n      this._triggerCaretChange({\n        type : 'CaretChange',\n        target : this.target,\n        caret : this.caret,\n        startAt : this.startAt, \n        stopAt : this.stopAt,\n        content : getContent(this.target),\n        selectedText : this.getSelectedText(),\n        charBeforCaret : this.getCharBeforCaret()\n      });\n    }else{\n      this.disable();\n    }\n    return true;\n  }\n}"]}